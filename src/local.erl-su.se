-module(local).

-export([
	 url2mnesia_userlist/1,
	 canonify_user/1,
	 canonify_numberlist/1
	]).

%% lookup
-export([
	 lookup_homedomain_url/1,
	 lookup_remote_url/1,
	 lookupregexproute/1,
	 lookupuser/1,
	 lookupuser_locations/2,
	 lookup_url_to_locations/1,
	 lookup_url_to_addresses/2,
	 lookup_addresses_to_users/1,
	 lookup_address_to_users/1,
	 lookupappserver/1,
	 lookupdefault/1,
	 lookuppotn/1,
	 lookupnumber/1,
	 lookupenum/1,
	 lookuppstn/1,
	 isours/1,
	 format_number_for_remote_party_id/3,
	 get_remote_party_name/2,
	 get_remote_party_number/4,
	 rewrite_potn_to_e164/1,
	 is_request_to_this_proxy/1,
	 remove_unsuitable_locations/2
	]).

%% siplocation
-export([
	 prioritize_locations/2,
	 homedomain/1,
	 get_locations_for_users/1,
	 get_user_with_contact/1
	]).

%% sipauth
-export([
	 get_user_verified/2,
	 get_user_verified_proxy/2,
	 can_use_address/2,
	 can_use_address_detail/2,
	 can_register/2,
	 is_allowed_pstn_dst/4,
	 canonify_authusername/2
	]).

%% sipuserdb
-export([
	 get_addresses_for_user/1,
	 get_addresses_for_users/1,
	 get_users_for_address_of_record/1,
	 get_users_for_addresses_of_record/1,
	 get_users_for_url/1,
	 get_user_with_address/1,
	 get_classes_for_user/1,
	 get_password_for_user/1,
	 get_telephonenumber_for_user/1,
	 get_forwards_for_users/1,
	 sipuserdb_backend_override/3,
	 sipuserdb_mysql_make_sql_statement/2
	]).

%% incomginproxy
-export([
	 incomingproxy_challenge_before_relay/3
	]).

%% pstnproxy
-export([
	 pstnproxy_route_pstn_not_e164/4
	]).

%% outgoingproxy
-export([
	 outgoingproxy_challenge_before_relay/3
	]).

%% sippipe
-export([
	 sippipe_received_response/3
	]).

%% cpl_db
-export([
	 user_has_cpl_script/1,
	 user_has_cpl_script/2,
	 get_cpl_for_user/1
	]).

%% transport layer
-export([
	 is_acceptable_socket/7,
	 is_tls_equivalent/3
	]).

%% custom log and mail cpl functions
-export([
	 cpl_mail/2,
	 cpl_log/4,
	 cpl_is_log_dest/1
	]).

%% configuration
-export([
	 check_config_type/3,
	 config_is_soft_reloadable/2
	]).

-include("siprecords.hrl").
-include("sipsocket.hrl").
-include("directory.hrl").
-include("sipproxy.hrl").

url2mnesia_userlist(URL) when is_record(URL, sipurl), is_list(URL#sipurl.user) ->
    [URL#sipurl.user ++ "@" ++ URL#sipurl.host];
url2mnesia_userlist(URL) when is_record(URL, sipurl) ->
    [].

% Turn a SIP username into an address which can be reached from anywhere.
% Used for example from the Mnesia userdb-module. It should be possible
% to call Mnesia users based on their username, but the username might
% need sip: prepended to it, or a default domain name appended to it.
canonify_user("sip:" ++ User) ->
    "sip:" ++ User;
canonify_user(Fulluser) ->
    case string:tokens(Fulluser, "@") of
        [_User, _Host] ->
            "sip:" ++ Fulluser;
        [User] ->
	    "sip:" ++ User ++ "@sip.su.se"
    end.

% Turns numbers into fully qualified tel: URLs or if that is not
% possible, return empty list. Used from some userdb-modules which
% get non-fully qualified phone numbers (like local extension numbers)
% back from the database.
canonify_numberlist([]) ->
    [];
canonify_numberlist(["tel:+" ++ E164 | Rest]) ->
    lists:append(["tel:+" ++ E164], canonify_numberlist(Rest));
canonify_numberlist(["+" ++ E164 | Rest]) ->
    case util:isnumeric(E164) of
	true ->
	    lists:append(["tel:+" ++ E164], canonify_numberlist(Rest));
	false ->
	    %% non-numerical, skip
	    canonify_numberlist(Rest)
    end;
canonify_numberlist([Number | Rest]) ->
    case rewrite_potn_to_e164(Number) of
	"+" ++ E164 ->
	    lists:append(["tel:+" ++ E164], canonify_numberlist(Rest));
	_ ->
	    canonify_numberlist(Rest)
    end.


%% Routing hooks
%%%%%%%%%%%%%%%%%

%% This function looks up the telephone number of the user in LDAP and
%% if a telephone number is found, looks it up using lookuppotn() which
%% first looks in ENUM and secondly looks for a PSTN gateway for the number
lookup_homedomain_url(URL) when is_record(URL, sipurl) ->
    {User, Host} = {URL#sipurl.user, URL#sipurl.host},
    Mail = User ++ "@" ++ Host,
    Loc1 = mail2tel(Mail),
    logger:log(debug, "Local routing: mail2tel ~p -> ~p", [Mail, Loc1]),
    case Loc1 of
	["+" ++ E164] ->
	    Loc2 = lookuppotn("+" ++ E164),
	    case Loc2 of
	        {proxy, Dst1} when is_record(Dst1, sipurl) ->
		    case sipurl:url_is_equal(URL, Dst1, [user, host]) of
			true ->
			    logger:log(debug, "Routing: POTN lookup resulted in what I started with, going for PSTN instead"),
			    lookuppstn("+" ++ E164);
			false ->
			    {proxy, Dst1}
		    end;
		Loc2 ->
		    Loc2
	    end;
	_ ->
	    Loc1
    end.

%% same as directory:lookup_mail2tel() but looks for the mail address in the mailLocalAddress attribute
lookup_mailLocalAddress2tel(Mail) ->
    case yxa_config:get_env(ldap_server) of
	{ok, LDAPserver} ->
	    Res = directory:ldapsearch_simple(LDAPserver, "mailLocalAddress", Mail, "telephoneNumber"),
	    logger:log(debug, "Local: LDAP mailLocalAddress -> telephoneNumber lookup on ~p -> ~p", [Mail, Res]),
	    Res;
	none ->
	    none
    end.

mail2tel(Mail) ->
    Loc1 = directory:lookup_mail2tel(Mail),
    case Loc1 of
	none ->
	    lookup_mailLocalAddress2tel(Mail);
	Loc1 ->
	    Loc1
    end.

lookup_remote_url(_URL) ->
    none.

is_request_to_this_proxy(Request) when is_record(Request, request) ->
    lookup:is_request_to_this_proxy(Request).


%% lookup.erl hooks
%%%%%%%%%%%%%%%%%%%%

lookupregexproute(User) ->
    lookup:lookupregexproute(User).

%% Returns : {proxy, URL} | {relay, URL} | {forward, URL} |
%%           {response, Status, Reason} | none | nomatch
lookupuser(URL) ->
    lookup:lookupuser(URL).

%% Returns : list() of siplocationdb_e record()
lookupuser_locations(Users, URL) ->
    lookup:lookupuser_locations(Users, URL).

%% Returns : list() of sipurl record()
remove_unsuitable_locations(URL, Locations) when is_record(URL, sipurl), is_list(Locations) ->
    lookup:remove_unsuitable_locations(URL, Locations).

lookup_url_to_locations(URL) ->
    lookup:lookup_url_to_locations(URL).

lookup_url_to_addresses(Src, URL) ->
    lookup:lookup_url_to_addresses(Src, URL).

lookup_addresses_to_users(Addresses) ->
    lookup:lookup_addresses_to_users(Addresses).

lookup_address_to_users(Address) ->
    lookup:lookup_address_to_users(Address).

lookupappserver(Key) ->
    lookup:lookupappserver(Key).

prioritize_locations(_Key, Locations) ->
    siplocation:prioritize_locations(Locations).

lookupdefault(URL) ->
    lookup:lookupdefault(URL).

lookuppotn(Number) ->
    lookup:lookuppotn(Number).

lookupnumber(Number) ->
    lookup:lookupnumber(Number).

lookupenum(Number) ->
    lookup:lookupenum(Number).

lookuppstn(Number) ->
    lookup:lookuppstn(Number).

isours(URL) ->
    lookup:isours(URL).

homedomain(Domain) ->
    lookup:homedomain(Domain).

%% Returns: {ok, RPI, Number} | none
get_remote_party_number(User, Header, URI, DstHost) ->
    lookup:get_remote_party_number(User, Header, URI, DstHost).

-define(E164toInternal, [{"^\\+46816([0-9][0-9][0-9][0-9])\$",    "\\1"},
			 {"^\\+468674(7[0-9][0-9][0-9])\$",       "\\1"},
			 {"^\\+4685537(8[0-9][0-9][0-9]+)\$",   "\\1"}]).

%% Returns: {ok, Number} | none
format_number_for_remote_party_id(Number, _Header, "sip1.telia.com") ->
    {ok, rewrite_potn_to_e164(Number)};
format_number_for_remote_party_id(Number, _Header, "sip2.telia.com") ->
    {ok, rewrite_potn_to_e164(Number)};
format_number_for_remote_party_id(Number, _Header, _DstHost) ->
    %% Rewrite number to an internal number if the gateway is not one of Telias
    case util:regexp_rewrite(Number, ?E164toInternal) of
	nomatch ->
	    {ok, Number};
	Match ->
	    {ok, Match}
    end.

%% Returns: {ok, DisplayName} | none
get_remote_party_name(Key, DstHost) ->
    case rewrite_potn_to_e164(Key) of
	"+" ++ E164 ->
	    lookup:get_remote_party_name("+" ++ E164, DstHost);
	_ -> none
    end.

rewrite_potn_to_e164(Key) ->
    lookup:rewrite_potn_to_e164(Key).


%% userdb hooks
%%%%%%%%%%%%%%%%

%% Looks up exactly one user with an Address. Used
%% for example in REGISTER. If there are multiple
%% users with an address, this function returns {error}.
get_user_with_address(Address) ->
   sipuserdb:get_user_with_address(Address).

%% Looks up all users with a given address. Used
%% to find out to which users we should send a request.
get_users_for_address_of_record(Address) ->
    sipuserdb:get_users_for_address_of_record(Address).

get_users_for_addresses_of_record(Addresses) ->
    sipuserdb:get_users_for_addresses_of_record(Addresses).

%% Gets all addresses for a user. Used for example
%% to check if a request from a user has an acceptable
%% From: header.
get_addresses_for_user(User) ->
    sipuserdb:get_addresses_for_user(User).

get_addresses_for_users(Users) ->
    sipuserdb:get_addresses_for_users(Users).

get_users_for_url(URL) ->
    sipuserdb:get_users_for_url(URL).

get_password_for_user(User) ->
    sipuserdb:get_password_for_user(User).

get_classes_for_user(User) ->
    Res = sipuserdb:get_classes_for_user(User),
    case Res of
	nomatch ->
	    case yxa_config:get_env(ldap_server) of
		{ok, Server} ->
		    case get_classes_for_user_is_itsuse(Server, User) of
			true ->
			    %% Override with default classes for it.su.se user since sipuserdb returned 'nomatch'
			    NewRes = [internal, national, mobile],
			    logger:log(debug, "Local: User ~p is an it.su.se user, granting default classes : ~p",
				       [User, NewRes]),
			    NewRes;
			false ->
			    Res
		    end;
		none ->
		    none
	    end;
	_ ->
	    Res
    end.

%% get_classes_for_user_is_itsuse/2, part of get_classes_for_user/2.
%% Determine if User belongs to "it.su.se" or not. Returns true | false
get_classes_for_user_is_itsuse(Server, User) when is_list(Server), is_list(User) ->
    %% look if User belongs to it.su.se
    case directory:ldapsearch(Server, "sipAuthenticationUser", User, ["sipAuthenticationUser"]) of
	[LR] when is_record(LR, ldapres) ->
	    Dn = LR#ldapres.dn,
	    DnLen = length(Dn),
	    MatchLen = 18,	%% length(",dc=it,dc=su,dc=se")
	    if
		DnLen >= MatchLen ->
		    %% Return 'true' if the end of Dn matches ",dc=it,dc=su,dc=se"
		    (string:substr(Dn, DnLen - MatchLen + 1, MatchLen) == ",dc=it,dc=su,dc=se");
		true ->
		    %% Dn not long enough to even compare
		    false
	    end;
	_ ->
	    false
    end.

get_telephonenumber_for_user("ft.sip1") ->
    "1225";
get_telephonenumber_for_user("ft.sip2") ->
    "1225";
get_telephonenumber_for_user(User) ->
    sipuserdb:get_telephonenumber_for_user(User).

%%get_forwards_for_users(["ft.sip2"]) ->
%%    [#sipproxy_forward{user      = "ft.sip2",
%%		       forwards  = [sipurl:parse("sip:0090510@pstnproxy.devel.sip.su.se")],
%%		       timeout   = 0,
%%		       localring = true
%%		      }];
get_forwards_for_users(Users) ->
    sipuserdb:get_forwards_for_users(Users).

%% Module   = atom(), sipuserdb module
%% Function = atom(), function in Module
%% Args     = term(), arguments to function
%% Returns : {ok, Res} | undefined
%%           If 'undefined' is returned, the real backend function will be called
sipuserdb_backend_override(_Module, _Function, _Args) ->
    undefined.

%% Returns : {ok, Res} | undefined
sipuserdb_mysql_make_sql_statement(_CfgKey, _Args) ->
    undefined.

%% Location lookup hooks
%%%%%%%%%%%%%%%%%%%%%%%%%

%% Looks up all contacts for a list of users. Used
%% to find out where a set of users are to see where
%% we should route a request.
get_locations_for_users(Users) ->
    siplocation:get_locations_for_users(Users).

%% Checks if any of our users are registered at the
%% location specified. Used to determine if we should
%% proxy requests to a URI without authorization.
get_user_with_contact(URI) ->
    siplocation:get_user_with_contact(URI).


%% AAA hooks
%%%%%%%%%%%%%

get_user_verified(Header, Method) ->
    sipauth:get_user_verified(Header, Method).

get_user_verified_proxy(Header, Method) ->
    sipauth:get_user_verified_proxy(Header, Method).

%% Returns: true | false
can_use_address("ata-hage10", URL) when is_record(URL, sipurl) ->
    true;
can_use_address(User, URL) when is_list(User), is_record(URL, sipurl) ->
    sipauth:can_use_address(User, URL).

%% Returns: {Verdict, Reason}
can_use_address_detail("ata-hage10", URL) when is_record(URL, sipurl) ->
    {true, ok};
can_use_address_detail(User, URL) when is_list(User), is_record(URL, sipurl) ->
    sipauth:can_use_address_detail(User, URL).

%% Returns : {{Verdict, Reason}, User} |
%%           {stale, User}             |
%%           {false, none}
%%           Verdict = true | false
%%           Reason  = ok | eperm | nomatch | error
can_register(Header, ToURL) when is_record(Header, keylist), is_record(ToURL, sipurl) ->
    sipauth:can_register(Header, ToURL).

is_allowed_pstn_dst(User, ToNumber, Header, Class) ->
    sipauth:is_allowed_pstn_dst(User, ToNumber, Header, Class).

%% Returns : NewUsername | undefined
canonify_authusername("ft", Header) when is_record(Header, keylist) ->
    {_, FromURL} = sipheader:from(Header),
    canonify_authusername2("ft", FromURL);
canonify_authusername(Username, Header) when is_list(Username), is_record(Header, keylist) ->
    undefined.

canonify_authusername2("ft", #sipurl{user="ft", host="it.su.se"}=FromURL) when is_record(FromURL, sipurl) ->
    logger:log(debug, "Auth: Using authentication username of 'ft.sip1' for this request"),
    "ft.sip1";
canonify_authusername2("ft", #sipurl{user="ft", host="pappersk.org"}=FromURL) when is_record(FromURL, sipurl) ->
    logger:log(debug, "Auth: Using authentication username of 'ft.sip2' for this request"),
    "ft.sip2".

%% incomingproxy hooks
%%%%%%%%%%%%%%%%%%%%%%%

incomingproxy_challenge_before_relay(Origin, Request, _Dst)
  when is_record(Origin, siporigin), is_record(Request, request) ->
    true.

%% pstnproxy hooks
%%%%%%%%%%%%%%%%%%%%%%%

%% Returns : undefined | nomatch | ignore | {relay, DstURI, NewRequest}
pstnproxy_route_pstn_not_e164(_DstNumber, _Request, _Origin, _THandler) ->
    undefined.

%% outgoingproxy hooks
%%%%%%%%%%%%%%%%%%%%%%%

outgoingproxy_challenge_before_relay(Origin, Request, _Dst)
  when is_record(Origin, siporigin), is_record(Request, request) ->
    true.

%% sippipe hooks
%%%%%%%%%%%%%%%%%

%% Returns: undefined | {huntstop, Status, Reason} | {next, NewDstList}
sippipe_received_response(_Request, _Response, _DstList) ->
    undefined.

% cpl_db hooks
%%%%%%%%%%%%%%%%

%% Returns: true | false
user_has_cpl_script(User) ->
    cpl_db:user_has_cpl_script(User).

%% Returns: true | false
user_has_cpl_script(User, Direction)->
    cpl_db:user_has_cpl_script(User, Direction).

%% Returns: term(), cpl script graph
%%get_cpl_for_user("ft.sip2") ->
%%    nomatch;
get_cpl_for_user(User) ->
    cpl_db:get_cpl_for_user(User).

%% transport layer hooks
%%%%%%%%%%%%%%%%%%%%%%%%%%

%% Returns: true | false | undefined
is_acceptable_socket(_Socket, _Dir, _Proto, _Host, _Port, _Module, _Subject) ->
    undefined.

%% Returns : true | false | undefined
is_tls_equivalent(_Proto, _Host, _Port) ->
    undefined.

%%--------------------------------------------------------------------
%% See cpl/README
%%--------------------------------------------------------------------
cpl_log(_LogName, _Comment, _User, _Request) ->
    undefined.

cpl_is_log_dest(_LogName) ->
    undefined.

cpl_mail(_Mail, _User) ->
    undefined.


%% configuration hooks
%%%%%%%%%%%%%%%%%%%%%%%

%%--------------------------------------------------------------------
%% Function: check_config_type(Key, Value, Src)
%%           Key     = atom()
%%           Value   = term()
%%           Src     = atom(), config backend module that found this
%%                             configuration parameter
%% Descrip.: Check a local configuration parameter. Local parameters
%%           are local_*.
%% Returns : {ok, NewValue} |
%%           {error, Msg}
%%           NewValue = term()
%%           Msg      = string()
%%--------------------------------------------------------------------
check_config_type(_Key, Value, _Src) ->
    {ok, Value}.

%%--------------------------------------------------------------------
%% Function: config_is_soft_reloadable(Key, Value)
%%           Key     = atom()
%%           Value   = term()
%% Descrip.: Check if it is possible to change a local configuration
%%           parameter with a soft reconfiguration (true), or if a
%%           complete restart of the application is necessary (false).
%% Returns : true | false
%%--------------------------------------------------------------------
config_is_soft_reloadable(_Key, _Value) ->
    true.
